<html>
  <head>
    <meta charset="utf-8">
    <style>
      *{
        font-family: 'Courier New', Courier, monospace;
        margin: 0;
        padding: 0;
      }
      body {
        background-color: rgb(27, 27, 34);
      }
      .wrapper {
        display: inline-block;
        position: absolute;
        left : 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
      }
      h1, h2 {
        margin-bottom: 20px;
        color: white;
      }
    </style>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix-min.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <script type="text/javascript">
      var mMatrix = mat4.create();
      var vMatrix = mat4.create();
      var pMatrix = mat4.create();

      var triangleVertexPositionBuffer;
      var triangleVertexColorBuffer;
      var squareVertexPositionBuffer;
      var squareVertexColorBuffer;

      var triangleVertexPositionBuffer;
      var squareVertexPositionBuffer;

      $(function() {
	      iniciaWebGL();
      });

      function iniciaWebGL() {
        var canvas = $('#canvas-webgl')[0];
        iniciarGL(canvas); 
        iniciarShaders();  
        iniciarBuffers();  
        iniciarAmbiente(); 
        desenharCena();    
      }

      function iniciarGL(canvas) {
        try {
          gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
          gl.viewportWidth = canvas.width;
          gl.viewportHeight = canvas.height;
        } catch(e) {
          if(!gl) alert("Não pode inicializar WebGL, desculpe");
        }
      }

      var shaderProgram;

      function iniciarShaders() {
        var vertexShader = getShader(gl, "#shader-vs");
        var fragmentShader = getShader(gl, "#shader-fs");
        
        shaderProgram = gl.createProgram();

        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
      
        if(!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
        	alert("Não pode inicializar shaders");
      
        gl.useProgram(shaderProgram);
      
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
        
        shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.vMatrixUniform = gl.getUniformLocation(shaderProgram, "uVMatrix");
        shaderProgram.mMatrixUniform = gl.getUniformLocation(shaderProgram, "uMMatrix");
      }
    
      function getShader(gl, id) {
        var shaderScript = $(id)[0];
        if(!shaderScript) 
          return null;

        var str = "";
        var k = shaderScript.firstChild;
        while(k) {
          if(k.nodeType == 3)
            str += k.textContent;
          k = k.nextSibling;
        }
        
        var shader;
        if(shaderScript.type == "x-shader/x-fragment")
          shader = gl.createShader(gl.FRAGMENT_SHADER);
        else if(shaderScript.type == "x-shader/x-vertex")
          shader = gl.createShader(gl.VERTEX_SHADER);
        else
          return null;
        
        gl.shaderSource(shader, str);
        gl.compileShader(shader);
        
        if(!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(shader));
          return null;
        }
        
        return shader;
      }

      function iniciarBuffers() {
        triangleVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        var vertices = [
          0.0, 1.0, 0.0,
          -1.0,-1.0, 0.0,
          1.0,-1.0, 0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        
        triangleVertexPositionBuffer.itemSize = 3;
        triangleVertexPositionBuffer.numItems = 3;

        triangleVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
        var cores = [
            1.0, 0.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 0.0, 1.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cores), gl.STATIC_DRAW);
        triangleVertexColorBuffer.itemSize = 4;
        triangleVertexColorBuffer.numItems = 3;


        squareVertexPositionBuffer = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);

        vertices = [
          1.0, 1.0, 0.0,
          -1.0, 1.0, 0.0,
          1.0,-1.0, 0.0,
          -1.0,-1.0, 0.0
        ];

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        squareVertexPositionBuffer.itemSize = 3;
        squareVertexPositionBuffer.numItems = 4;

        squareVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer);
        cores = []
        for (var i=0; i < 4; i++) {
          cores = cores.concat([0.5, 0.5, 1.0, 1.0]);
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(cores), gl.STATIC_DRAW);
        squareVertexColorBuffer.itemSize = 4;
        squareVertexColorBuffer.numItems = 4;
      }

      function iniciarAmbiente() {
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
      }

      function desenharCena() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        mat4.perspective(pMatrix, 45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0);
        mat4.identity(mMatrix);
        mat4.identity(vMatrix);
        
        var translation = vec3.create();

        vec3.set (translation, 5.65, 12.35, -16); 
        mat4.translate(mMatrix, mMatrix, translation);

        let start_y = 0.0
        let size = 4.5

        let draw_squares = () => {
          for ( let i = 0; i < 4; i++ ) {
            vec3.set (translation, -size * 3, -size, 0); 
            mat4.translate(mMatrix, mMatrix, translation);
            gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, triangleVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
            setMatrixUniforms();
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
            for ( let j = 0; j < 3; j++ ) {
              vec3.set (translation, size, 0.0, 0.0); 
              mat4.translate(mMatrix, mMatrix, translation);
              gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
              gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

              setMatrixUniforms();
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
            }
          }
        }

        let draw_triangles = () => {
          for ( let i = 0; i < 4; i++ ) {
            vec3.set (translation, -size * 3, -size, 0); 
            mat4.translate(mMatrix, mMatrix, translation);
            gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer);
            gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, squareVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
            setMatrixUniforms();
            gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);

            for ( let j = 0; j < 3; j++ ) {
              vec3.set (translation, size, 0, 0); 
              mat4.translate(mMatrix, mMatrix, translation);
              gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
              gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
              setMatrixUniforms();
              gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);
            }
          }

        }

        draw_squares()
        vec3.set (translation, 2.2, 15.8, 0); 
        mat4.translate(mMatrix, mMatrix, translation);
        draw_squares()
        vec3.set (translation, 0, 20.2, 0); 
        mat4.translate(mMatrix, mMatrix, translation);
        draw_triangles()
        vec3.set (translation, -2.2, 15.8, 0); 
        mat4.translate(mMatrix, mMatrix, translation);
        draw_triangles()

      }

      function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.vMatrixUniform, false, vMatrix);
        gl.uniformMatrix4fv(shaderProgram.mMatrixUniform, false, mMatrix);
      }

    </script>
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec3 aVertexPosition;
      attribute vec4 aVertexColor;
      
      uniform mat4 uMMatrix;
      uniform mat4 uVMatrix;
      uniform mat4 uPMatrix;
      
      varying vec4 vColor;
      
      void main(void) {
        gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
      }
    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
      precision mediump float;
      varying vec4 vColor;
      
      void main(void) {
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
        gl_FragColor = vColor;
      }
    </script>
  </head>
  <body>
    <div class='wrapper'>
      <h1>Trabalho 2 CG</h1>
      <h2>Leonam Teixeira de Vasconcelos</h2>
      <canvas id="canvas-webgl" width="500px" height="500px" style="border:none">
      </canvas>
  </div>
  </body>
</html> 